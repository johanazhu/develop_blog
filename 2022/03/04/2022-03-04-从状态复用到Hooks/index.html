<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="azhubaby的技术博客"><title>一文概述：从状态复用到Hooks | Azhubaby Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.2"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script src="https://www.googletagmanager.com/gtag/js?id=G-3Q5NWFLRS6" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-3Q5NWFLRS6');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + 'b735438e944e58cd4b0914986a8f821c';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "i1ldktvgdr");
</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 5.4.2"></head><body><header class="clearfix" id="header"><div class="container"><div class="col-group"><div class="site-name"><h1 class="hidden">一文概述：从状态复用到Hooks</h1><a id="logo" href="/.">Azhubaby Blog</a><p class="description">关于编程、个人成长以及思考</p></div><div> <nav class="clearfix" id="nav-menu"><a class="current" href="/."><i class="fa undefined"> 首页</i></a><a href="/archives/"><i class="fa undefined"> 归档</i></a><a href="/tags/"><i class="fa undefined"> 标签</i></a><a href="/about/"><i class="fa undefined"> 关于</i></a><a class="search-icon" href="javascript:void(0)"><i class="fa fa-search"></i></a></nav></div></div></div></header><div id="body"><div class="container"><div class="col-group"><div class="col-8" id="main"><div class="res-cons"><div class="post"><h1 class="post-title">一文概述：从状态复用到Hooks</h1><div class="post-meta">2022-03-04<span> | </span><span class="category"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/">前端开发</a><!--busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js--><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React/">React</a><!--busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js--></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span> | </span><span>作者：</span><span class="author">门罗币</span></div><div class="post-content"><blockquote>
<p>学习一项知识，必须问自己三个重要问题：1. 它的本质是什么。2. 它的第一原则是什么。3. 它的知识结构是怎样的</p>
</blockquote>
<h2 id="测试一下-Hooks-的熟练程度"><a href="#测试一下-Hooks-的熟练程度" class="headerlink" title="测试一下 Hooks 的熟练程度"></a>测试一下 Hooks 的熟练程度</h2><p>为什么不能在 for 循环、if 语句里使用 Hooks</p>
<p>React.memo、React.useCallback、React.usememo 的作用，以及对比</p>
<p>useState 中的值是个对象，改变对象中的值，组件会渲染吗？如果用 React.memo() 包裹住呢</p>
<p>Hooks 的（实现）原理是什么？</p>
<p>Hooks 的本质是什么？为什么？</p>
<p>React Hooks，它带来了哪些便利？</p>
<p>React Hooks 当中的 useEffect 是如何区分生命周期钩子的</p>
<p>useEffect(fn, []) 和 componentDidMount 有什么差异</p>
<hr>
<p>回答得如何？在了解一个概念前，疑惑越多，理解就越深</p>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>React Hooks 是  React 16.8 推出的新特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</p>
<h2 id="为什么会有-Hooks"><a href="#为什么会有-Hooks" class="headerlink" title="为什么会有 Hooks"></a>为什么会有 Hooks</h2><p>我们一定要有个概念，即 React 的本质是什么？它的特征是 UI=f(data)、一切皆组件、声明式编程。那么，既然是 UI=f(data)，data（数据）通过 function 来驱动 UI 视图变化。在业务中，你不能简单只展示，也需交互，交互就会更新状态，React 是通过 setState 来改变状态。但这仅限于类组件，所以在Hooks出现之前，函数式组件用来渲染组件（也称它为木偶组件），类组件用来控制状态</p>
<p>而后，为了让状态能更好的复用，提出了<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/react-without-es6.html#mixins">Mixins</a> 、<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/render-props.html">render props</a> 和 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/higher-order-components.html">高阶组件</a>。诚然，render props、高阶组件能虽然能解决，但是会带来副作用——组件会形成“嵌套地狱”</p>
<p>以及类组件本身的生命周期会使得复杂的组件变得难以理解、class 语法的学习成本等等，构成了React 团队提出 hooks——让函数式组件拥有状态管理</p>
<p><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation">官网</a>也阐述过设计Hooks的三大动机：</p>
<blockquote>
<ol>
<li>在组件之间复用状态逻辑很难</li>
<li>复杂组件变得难以理解</li>
<li>难以理解的 class</li>
</ol>
</blockquote>
<h2 id="状态复用的实验"><a href="#状态复用的实验" class="headerlink" title="状态复用的实验"></a>状态复用的实验</h2><h3 id="Mixins时代"><a href="#Mixins时代" class="headerlink" title="Mixins时代"></a>Mixins时代</h3><p>在笔者尚未使用 React 之前就存在，现已被淘汰</p>
<blockquote>
<p>Mixins（混入）是一种通过扩展收集功能的方式，它本质上是将一个对象的属性拷贝到另一个对象上，不过你可以拷贝任意多个对象的任意个方法到一个新对象上去，这是继承所不能实现的。它的出现主要就是为了解决代码复用问题</p>
</blockquote>
<p>这里不对其做分析，React官方文档在 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/blog/2016/07/13/mixins-considered-harmful.html">Mixins Considered Harmful</a> 一文中提到了 Mixins 带来的危害：</p>
<ul>
<li>Mixins 可能会相互依赖，相互耦合，不利于代码维护</li>
<li>不同的 Mixins 中的方法可能会相互冲突</li>
<li>Mixins 非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球的复杂性</li>
</ul>
<h3 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a>Render Props</h3><p>指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术</p>
<p>具有 render prop 的组件接受一个返回 React 元素的函数，并在组件内部通过调用此函数来实现自己的渲染逻辑</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">DataProvider</span> render=&#123;<span class="function"><span class="params">data</span>=&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;data.target&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)&#125;&gt;</span><br></pre></td></tr></table></figure>

<p>具体可在<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/render-props.html">官网</a>了解</p>
<h3 id="HOC（高阶组件）"><a href="#HOC（高阶组件）" class="headerlink" title="HOC（高阶组件）"></a>HOC（高阶组件）</h3><p>HOC的原理其实很简单，它就是一个函数，并且它接受一个组件作为参数，并返回一个新的组件，把复用的地方放在高阶组件中，你在使用的时候，只需要做不同用处</p>
<p>打个比方：就好像给你一瓶水，你在渴的时候就会喝它；你在耍帅的时候拿它摆POSE；你在别人需要的时候给他喝帮助人…</p>
<p>Writing is cheap. Show me code</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Wrapper(WrappedComponent) &#123;</span><br><span class="line">    return class extends React.Component &#123;</span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">            console.log(&#x27;我是一瓶水&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;div className=&quot;title&quot;&gt;&#123;this.props.title&#125;&lt;/div&gt;	</span><br><span class="line">                    &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">                &lt;/div&gt;	</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import &quot;./styles.css&quot;;</span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import Wrapper from &quot;./Wrapper&quot;;</span><br><span class="line"></span><br><span class="line">class A extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;喝它&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;耍帅摆POSE&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;帮助别人&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const AA = Wrapper(A);</span><br><span class="line">const BB = Wrapper(B);</span><br><span class="line">const CC = Wrapper(C);</span><br><span class="line"></span><br><span class="line">export default function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;h1&gt;Hello CodeSandbox&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;Start editing to see some magic happen!&lt;/h2&gt;</span><br><span class="line">      &lt;AA title=&quot;我是普通人&quot; /&gt;</span><br><span class="line">      &lt;BB /&gt;</span><br><span class="line">      &lt;CC /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样就很明显的看出 HOC 的好处，”一瓶水“是共同代码，A、B、C处理业务代码，然后将A、B、C传入HOC（一瓶水）中，返回了一个新的组件 AA、BB、CC。相同的代码得到了公用</p>
<p><img src="https://i.loli.net/2021/09/17/q7vQpZwIngNc3C2.png" alt="HOC-demo"></p>
<p>各位可以前往这里查看 <a target="_blank" rel="noopener" href="https://codesandbox.io/s/hoc-demo-d9p9j?file=/src/App.js:0-629">demo</a></p>
<p>HOC 的用处不单单是代码复用，还可以做权限控制、打印日志等。但它的缺陷也没明显，当大量使用 HOC 后，会产生大量的嵌套，使得嵌套变得困难；并且 HOC 会劫持 props，在不遵守约定的情况下可能会造成冲突</p>
<p>总结下 HOC：</p>
<ul>
<li>用法：创建一个函数，该函数接收一个组件作为输入，除了组件还可以传递其他的参数，基于该组件返回一个不同的组件</li>
<li>优点：代码复用，逻辑复用</li>
<li>缺点：因为嵌套使得调试难度变高；会劫持props，或许造成冲突</li>
</ul>
<h2 id="Hooks-的出世"><a href="#Hooks-的出世" class="headerlink" title="Hooks 的出世"></a>Hooks 的出世</h2><p>前有状态复用的不给力（ Mixins 被淘汰，render props、HOC 的副作用又大），后有类组件的复杂组件难以理解、维护（过多的生命周期），class 属性造成的 this 指向又麻烦。于是乎，Hooks 大喊一声：我来也</p>
<p>它起码有三个好处</p>
<ul>
<li>逻辑复用<ul>
<li>秒杀render props、hoc</li>
</ul>
</li>
<li>业务代码更聚合<ul>
<li>秒杀类组件</li>
</ul>
</li>
<li>写法简洁<ul>
<li>秒杀类组件</li>
</ul>
</li>
</ul>
<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>作用：让函数组件具有维持状态的能力，替代类组件的constructor初始化状态</p>
<p>例子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count+1)&#125;&gt;&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：逻辑复用</p>
<p>在使用 useState 时，会出现两个衍生问题：</p>
<h3 id="一：Capture-Value-特性"><a href="#一：Capture-Value-特性" class="headerlink" title="一：Capture Value 特性"></a>一：Capture Value 特性</h3><p>在<a href="https://blog.azhubaby.com/2022/03/01/2022-03-01-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%B1%BB%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/">函数式组件与类组件有何不同</a>中曾介绍过，<strong>函数式组件能捕获渲染时所用的值</strong>。并举例组件中点三下加， setTimeout 3秒后弹出数字，在点两次加，3秒后展示3，而不是5。而类组件却能获得最新的数据，这是为什么？</p>
<p>因为函数式组件有 Capture Value 的特性。而从源码的角度看，每次调用 setXX 会引发 re-render 从而重渲染组件</p>
<p>如果想获得最新值，可以通过 useRef 来将值保存在内存中</p>
<h3 id="二：useState-中的值是个对象，改变对象中的值，组件会渲染吗？怎么优化？"><a href="#二：useState-中的值是个对象，改变对象中的值，组件会渲染吗？怎么优化？" class="headerlink" title="二：useState 中的值是个对象，改变对象中的值，组件会渲染吗？怎么优化？"></a>二：useState 中的值是个对象，改变对象中的值，组件会渲染吗？怎么优化？</h3><p>一般我们用 useState 尽量遵守单一值，但难免会遇到一些特殊情况，如果值是个对象，改变对象中的其中一个属性，其他属性不变，那么引用其他属性的组件是否会渲染呢？</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">DemoSon</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;render&quot;</span>, props);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Demo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(&#123; <span class="attr">foo</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;johan&quot;</span>, <span class="attr">bar</span>: &#123; <span class="attr">baz</span>: <span class="number">1</span> &#125; &#125; &#125;);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setData</span>(&#123;</span><br><span class="line">      ...data,</span><br><span class="line">      <span class="attr">foo</span>: &#123;</span><br><span class="line">        ...data.<span class="property">foo</span>,</span><br><span class="line">        <span class="attr">bar</span>: &#123;</span><br><span class="line">          <span class="attr">baz</span>: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;data.foo.bar.baz&#125;</span></span><br><span class="line"><span class="language-xml">	  <span class="tag">&lt;<span class="name">DemoSon</span> <span class="attr">name</span>=<span class="string">&#123;data.foo.name&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>点击 div，修改 baz 的值，DemoSon 是否会渲染呢？答案是会的，为什么会渲染？因为你的引用值发生了变化，生成了新的虚拟DOM，渲染到视图上时，子组件就会渲染。如何优化，让数据不变的组件不重复渲染？我觉得有两种方式，一拆分 data，拆分成 foo 对象和name，因为 setData 并不改变 name，所以DemoSon 不会渲染，还有一种是通过 memo 包裹住 DemoSon，因为 memo 能避免重新渲染</p>
<p>可查看线上 <a target="_blank" rel="noopener" href="https://codesandbox.io/s/usestateyin-ru-dui-xiang-98sxiw?file=/src/Demo.js">demo</a></p>
<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>作用：处理副作用，替代类组件的componentDidMount、componentDidUpdate、componentWillUnmount</p>
<p>使用方式：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有第二个参数</span></span><br><span class="line"><span class="comment">// mount 阶段和 update 阶段都执行</span></span><br><span class="line"><span class="title function_">useEffect</span>(fn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个参数为空数组</span></span><br><span class="line"><span class="comment">// 当 mount 阶段会执行</span></span><br><span class="line"><span class="title function_">useEffect</span>(fn,[])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个参数为依赖项</span></span><br><span class="line"><span class="comment">// 当依赖项（deps）数据更新时会执行</span></span><br><span class="line"><span class="title function_">useEffect</span>(fn, [deps])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除副作用 </span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = props.<span class="property">source</span>.<span class="title function_">subscribe</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 清除订阅</span></span><br><span class="line">    subscription.<span class="title function_">unsubscribe</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PS：以上注释中的 mount 阶段，即组件加载时；update 指数据（包括props、state）变化时</p>
</blockquote>
<p>在使用 useEffect 时，会面临几个问题：</p>
<h3 id="1-useEffect-fn-和-componentDidMount-有什么区别？"><a href="#1-useEffect-fn-和-componentDidMount-有什么区别？" class="headerlink" title="1. useEffect(fn, []) 和 componentDidMount 有什么区别？"></a>1. useEffect(fn, []) 和 componentDidMount 有什么区别？</h3><p>虽然 useEffect(fn, [])  和 componentDidMount  都可以表示组件加载时执行，但从细节上两者有所不同。要谈起细节需从源码中聊起，具体可看 React 源码魔术师卡颂的这篇——<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzkzMjIxNTcyMA==&mid=2247485312&idx=1&sn=c55814b0e864dce6133b8f0a8f4e8d65&source=41#wechat_redirect">useEffect(fn, [])和cDM有什么区别？</a> 了解，这里我讲下我的理解</p>
<p>源码中把虚拟DOM和虚拟DOM渲染到真实DOM分为两个阶段。虚拟DOM存在内存中，在 JSX 中对数据增删改，虚拟DOM会对对应的数据打上标签，这个阶段称为 render 阶段；把虚拟DOM映射到真实DOM的操作被称为 commit 阶段，它负责把这些标签转换为具体的DOM操作</p>
<p>在 render 阶段</p>
<ul>
<li>插入 DOM 元素被打上 Placement 标签；</li>
<li>更新 DOM 元素被打上 Update 标签；</li>
<li>删除 DOM 元素被打上 Deletion 标签；</li>
<li>更新 Ref 属性被打上 Ref 标签</li>
<li>useEffect 回调被打上 Passive 标签</li>
</ul>
<p>而 commit 阶段分为三个子阶段</p>
<ul>
<li>渲染视图前（before mutation 阶段）</li>
<li>渲染视图时（mutation 阶段）</li>
<li>渲染视图后（layout 阶段）</li>
</ul>
<p>被打上 Placement 标签的，会在 mutation 阶段时执行对应的 appendChild 操作，意味着 DOM 节点被插入到视图中，接着在 layout 阶段调用 componentDidMount </p>
<p>而被打上 Passive 标签的，它会在 commit 阶段的三个子阶段执行完成后再异步调用 useEffect 的回调函数</p>
<p>由此可见，它们的调用<strong>调用时机</strong>是不同的，useEffect(fn,[]) 是在 commit 阶段执行完以后异步调用回调函数，而 componentDidMount 会在 commit 阶段完成视图更新（mutation阶段）后再 layout 阶段同步调用</p>
<blockquote>
<p>hooks 中也有一个和 componentDidMount 调用时机相同的 hooks——useLayoutEffect</p>
</blockquote>
<p>其次useEffect(fn, []) 会捕获 props 和state，而 componentDidMount 并不会。使用 useEffect(fn, []) 的会第哦啊函数会拿到初始的 props 和 state，这个道理和 capture value 是一个道理</p>
<p>总结：两点不同，一、执行时机不同；二、useEffect(fn, []) 会对 props 和 state 进行捕获</p>
<blockquote>
<p>下文会用demo说明 capture value 特性</p>
</blockquote>
<h3 id="2-每一次渲染都有它自己的-props-和-state"><a href="#2-每一次渲染都有它自己的-props-和-state" class="headerlink" title="2. 每一次渲染都有它自己的 props 和 state"></a>2. 每一次渲染都有它自己的 props 和 state</h3><p>先讨论一下渲染（rendering），我们来看一个计数器组件 Counter</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>点击 &#123;count&#125; 次<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        点击</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次渲染时，count 的初始值从 useState(0) 中获取。当调用 setCount(count + 1) ，React 重新渲染组件，此时 count 的值就成 1。如下所示：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mount 第一次渲染</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">0</span>; <span class="comment">// 默认从useState 中获得</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>点击 &#123;count&#125; 次<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update 点击 1 次</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">1</span>; <span class="comment">// 通过 setCount 修改 count</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>点击 &#123;count&#125; 次<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update 点击 2 次</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">2</span>; <span class="comment">//  通过 setCount 修改 count</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>点击 &#123;count&#125; 次<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每当我们更新状态时，React 会重新渲染组件。每次渲染获得此刻（快照）的 count 状态</p>
<p>而在类组件中并不是捕获值</p>
<p>举个例子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassDemo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是Class Component, &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>页面上的 count 会每隔一秒钟加1，而换成函数式组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">FunctionDemo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>我是Function Component, &#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>永远是1</p>
<p>这就是 hooks 的capture value，类似例子在<a href="https://blog.azhubaby.com/2022/03/01/2022-03-01-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%B1%BB%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/">函数式组件与类组件有何不同</a>介绍过</p>
<p>可前往<a target="_blank" rel="noopener" href="https://codesandbox.io/s/weathered-water-6yfdtf?file=/src/ClassDemo.js:175-266">线上demo</a>查看</p>
<h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><p>作用：同步执行副作用</p>
<p>大部分情况下，使用 useEffect 就可以帮我们处理副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行</p>
<p>与类组件中的 componentDidMount 效果一致，都是在 commit 阶段完成视图更新（mutation阶段）后在 layout阶段同步调用</p>
<h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>作用：记忆函数，避免函数重新生成。在函数传递给子组件时，可以避免子组件重复渲染</p>
<p>例子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = <span class="title function_">useCallback</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">doSomething</span>(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>可缓存的引用</p>
<p>在类组件中常困扰人的是 this 绑定问题</p>
<ol>
<li> render 方法中使用bind</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this &gt; &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>render方法中使用箭头函数</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this &gt; &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;e</span> =&gt;</span> this.handleClick(e)&#125;&gt;test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>构造函数中bind</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this &gt; &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.在定义阶段使用箭头函数绑定</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this &gt; &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前三种都会因 App 组件的props或state 变化而重新触发渲染，使其渲染新的handleClick。第四种将handleClick抽离出赋值为变量，通过 this 指向存储函数，起到了缓存作用</p>
<p>而函数式组件一定会渲染</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Click&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">    	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是 useCallback 能缓存函数，让它”记住“</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> handleClick = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Click&#x27;</span>);</span><br><span class="line">    &#125;, [])</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">    	 <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Demo</span> <span class="attr">handleClick</span>=<span class="string">&#123;handleClick&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但使用 useCallback 必须使用 shouldComponentUpdate 或者 React.memo 来忽略同样的参数重复渲染</strong></p>
<p>所以单独使用 useCallback 是不能的，它需要和 React.memo 配合</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Demo</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;props.handleClick&#125;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MemoDemo</span> = <span class="title function_">memo</span>(<span class="title class_">Demo</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> handleClick = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Click&#x27;</span>);</span><br><span class="line">    &#125;, [])</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">    	 <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Demo</span> <span class="attr">handleClick</span>=<span class="string">&#123;handleClick&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是 useCallback 会使代码可读性变差，所以尽量不用 useCallback</p>
<p>不用 useCallback ，那怎么提高性能呢？</p>
<h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>作用：记忆组件。替代类组件的shouldComponentUpdate</p>
<p>useCallback 的功能完全可以由 useMemo 所取代，如果你想通过 useMemo 返回一个记忆函数也是完全可以的</p>
<p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code></p>
<p>例子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">computeExpensiveValue</span>(a, b), [a, b]);</span><br></pre></td></tr></table></figure>

<p>默认情况下，如果 React 父组件重新渲染，它包含的所有子组件都会重新渲染，即使子组件没有任何变化</p>
<p>useMemo 和 useCallback 接受的参数都是一样，都是在其依赖项发生变化后执行，都是返回缓存的值，区别在于 useMemo 返回的是函数运行的结果，useCallback 返回的是函数</p>
<p>useMemo 返回的是一个值，用于避免在每次渲染时都进行高开销的计算</p>
<h4 id="useCallback-VS-useMemo"><a href="#useCallback-VS-useMemo" class="headerlink" title="useCallback VS useMemo"></a>useCallback VS useMemo</h4><p>相同点：useCallback 和 useMemo 都是性能优化的手段，类似于类组件的 shouldComponentUpdate，在子组件中使用 shouldComponentUpdate，判断该组件的 props 和 state 有没有变化，从而避免每次父组件 render 时重新渲染子组件</p>
<p>区别：useCallback 和 useMemo 的区别是 useCallback 返回一个函数，当把它返回的这个函数作为子组件使用时，可以避免每次父组件更新时重新渲染这个子组件</p>
<h2 id="memo"><a href="#memo" class="headerlink" title="memo"></a>memo</h2><p>作用：避免重新渲染</p>
<p>只有当 props 改变时会重新渲染子组件</p>
<p>被 memo 包裹住后，当 props 不变时，子组件就不会渲染</p>
<p>React.memo() 方法可以防止子组件不必要渲染，从而提供组件性能。</p>
<p>关于性能优化 Dan 曾写过一篇文章：<a target="_blank" rel="noopener" href="https://overreacted.io/zh-hans/before-you-memo/">在你写memo()之前</a>，其实在我们使用 useCallback、useMemo、memo前不妨试试 state 下移和内容提升。目的就是让不用渲染的组件不重复渲染</p>
<h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>作用：</p>
<p>保存引用值，跟 createRef 类似。我们习惯用 ref 保存 DOM</p>
<p>使用 useRef 保存和更新一些数据是有一定好处的，<strong>它可以不通过内存来保存数据</strong>，使得这些数据再重渲染时不会被清除掉</p>
<p>它不仅仅是用来管理DOM ref 的，它还相当于 this，可以存放任何变量，很好的解决闭包带来的不方便性</p>
<p>如果我们想利用普通的变量再重渲染过程中追踪数据变化是不可行的，因为每次组件渲染时它都会被重新初始化。然而，如果使用 ref 的话，其中的数据能在每次组件渲染时保持不变。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState&lt;number&gt;(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> countRef = useRef&lt;number&gt;(count)</span><br></pre></td></tr></table></figure>

<p>在<a href="https://blog.azhubaby.com/2022/03/01/2022-03-01-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%B1%BB%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/">函数式组件与类组件有何不同</a>介绍过使用方法</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>useContext：减少组件层级</p>
<p>useReducer： 类 redux 的方法，useState 是基于它扩张的</p>
<p>ForwardRef：转发 ref</p>
<p>useImperativeHandle ：透传 Ref，父组件获取子组件内的方法</p>
<h2 id="自定义-Hooks"><a href="#自定义-Hooks" class="headerlink" title="自定义 Hooks"></a>自定义 Hooks</h2><p>由于 useState 和 useEffect 是函数调用，因为我们可以将其组合成自己的 Hooks</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyResponsiveComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> width = <span class="title function_">useWindowWidth</span>();</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    	<span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span> Window width is &#123;width&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>	</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useWindowWidth</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [width, setWidth] = <span class="title function_">useState</span>(<span class="variable language_">window</span>,innerWidth);</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">handleResize</span> = (<span class="params"></span>) =&gt; <span class="title function_">setWidth</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>)</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize)</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义 Hooks 让不同的组件共享可重用的状态逻辑。注意状态本身是不共享的。每次调用 Hook 都只声明了其自身的独立状态</p>
<h2 id="React-Hooks的不足"><a href="#React-Hooks的不足" class="headerlink" title="React Hooks的不足"></a>React Hooks的不足</h2><p>虽然实现了大多数类组件的功能，但是还无法实现 getSnapshotBeforeUpdate 和 componentDidCatch 这两个 API</p>
<h2 id="附录：使用规则"><a href="#附录：使用规则" class="headerlink" title="附录：使用规则"></a>附录：使用规则</h2><p>Hooks 的本质就是 JavaScript 函数，在使用它时需要遵守<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-rules.html">两条规则</a></p>
<blockquote>
<h4 id="只在最顶层使用-Hook"><a href="#只在最顶层使用-Hook" class="headerlink" title="只在最顶层使用 Hook"></a>只在最顶层使用 Hook</h4><p><strong>不要在循环，条件或嵌套函数中调用 Hook</strong>，确保总是在你的 React 函数的最顶层以及任何 return 之前调用他们。遵守这条规则，你就能确保 Hook 在每次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确</p>
<h4 id="只在-React-函数中调用-Hook"><a href="#只在-React-函数中调用-Hook" class="headerlink" title="只在 React 函数中调用 Hook"></a>只在 React 函数中调用 Hook</h4><p>不要再普通的 JavaScript 函数中调用 Hook，你可以：</p>
<ul>
<li>在 React 的函数组件中调用 Hook</li>
<li>在自定义 Hook 中调用其他 Hook</li>
</ul>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903815762673671">【React深入】从Mixin到HOC再到Hook</a></li>
<li><a target="_blank" rel="noopener" href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/">useEffect 完整指南</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5dd64ae6f265da478b00e639">useCallback、useMemo 分析以及差别</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/happylindz/blog/issues/19">十个案例学会 React Hooks</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/MzpUROCRYPpwOycI2sz3lQ">useEffect, useCallback, useMemo三者有何区别</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247488110&idx=1&sn=f7c142fb65259f22773bb2bad4ccf8ca&chksm=ea0d5894dd7ad18236c174f1b5776f933473c7d6e3d3f95b3f57516d5594552ad7414198d1f4&scene=126&sessionid=1617017984&key=74e411ceb40c53ecceeb837c57022e68713e07c93481427e7e48bce03a829b9867bfe6e59e4db1e1b7bcf1db392c63aecc4ac96c0d04c594bf4f1dcaadb7e77fc37f8e6cb0405ba447bbd29ac158bdfe5f8d98515a27c910f031d65e34617eaa75ab601ef2a0780a16db37bc7c58280e68401ba0ae105a59274bb9a0ed6d1d16&ascene=1&uin=MTA0NTY0NDM2MQ==&devicetype=Windows+10+x64&version=62090070&lang=zh_CN&exportkey=ATPQQ5EDyogKCw2h+uLo8yA=&pass_ticket=rOrDQ7aYmbIfx6AGR+Uc8RcjMfmD7fSjUCfVAc87kvPd+MLrrXll+mIbzLV5R7OT&wx_header=0">React hooks 最佳实践【更新中】</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6948748617817522206">React Hooks 万字总结</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/-WLQPNHF2zzPB1v1Lwkw1w">「React万字基础全面剖析」</a></li>
<li><a target="_blank" rel="noopener" href="https://felixgerschau.com/react-hooks-separation-of-concerns/">Separation of concerns with React hooks</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/357020049/answer/909484669?utm_source=wechat_session&utm_medium=social&utm_oi=56197411504128&utm_content=group2_Answer&utm_campaign=shareopn">如何去合理使用 React hook？</a></li>
<li><a target="_blank" rel="noopener" href="https://alexsidorenko.com/blog/react-render-always-rerenders/">使用 React.memo() 提高组件性能</a></li>
<li><a target="_blank" rel="noopener" href="https://alexsidorenko.com/blog/react-render-always-rerenders/">react-render-always-rerenders</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzkzMjIxNTcyMA==&mid=2247485312&idx=1&sn=c55814b0e864dce6133b8f0a8f4e8d65&source=41#wechat_redirect">useEffect(fn, [])和cDM有什么区别？</a></li>
<li><a target="_blank" rel="noopener" href="https://overreacted.io/zh-hans/before-you-memo/">在你写memo()之前</a></li>
</ul>
</div><div class="tags"><a href="/tags/React/"><i class="fa fa-tag"></i>React</a><a href="/tags/Hooks/"><i class="fa fa-tag"></i>Hooks</a></div><div class="post-nav"><a class="pre" href="/2022/03/08/2022-03-08-Promise%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%9D%E8%80%83%E5%BB%B6%E4%BC%B8/">Promise面试题思考延伸</a><a class="next" href="/2022/03/01/2022-03-01-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%B1%BB%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/">函数式组件与类组件有何不同</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: 'ff0c33d53db26a5b1424',
  clientSecret: 'd42b8e0556a1f4e20667e0a48c1adb9eca12d6ee',
  repo: 'blog',
  owner: 'johanazhu',
  admin: ['johanazhu'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div id="secondary"><div class="widget"><div class="widget-title"><h3> 我的微信公众号</h3></div><div class="wechatwidget"><a href="#"><img src="https://s2.loli.net/2022/03/25/VqfD2ScLuKzjbR8.jpg"/></a><span>微信号：johanbo88</span></div></div><div class="widget"><div class="widget-title"><h3>最近文章</h3></div><ul class="widget-list"><li class="widget-list-item"><a class="widget-list-link" href="/2023/08/06/2023-08-06-%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BE%E5%A4%87%E8%AE%BF%E9%97%AEWSL%E9%A1%B9%E7%9B%AE/">局域网设备访问WSL项目</a></li><li class="widget-list-item"><a class="widget-list-link" href="/2023/07/26/2023-07-26-%E7%8E%B0%E4%BB%A3SEO%E8%AF%A5%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88/">现代SEO该做些什么</a></li><li class="widget-list-item"><a class="widget-list-link" href="/2023/06/21/2023-06-21-%E6%88%91%E7%9A%84%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%81%9A%E5%93%AA%E4%BA%9B/">我的云服务器初始化做哪些（持续更新）</a></li><li class="widget-list-item"><a class="widget-list-link" href="/2023/05/22/2023-05-22-Vite+React+TypeScript%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">Vite + React + TypeScript 最佳实践（2023）</a></li><li class="widget-list-item"><a class="widget-list-link" href="/2023/04/24/2023-04-24-%E5%87%A1%E4%BA%BA%E6%BF%80%E5%8A%B150%E8%A8%80/">凡人激励五十言</a></li></ul></div><div class="widget"><div class="widget-title"><h3> 分类</h3></div><ul class="widget-list"><li class="widget-list-item"><a class="widget-list-link" href="/categories/10X%E7%A8%8B%E5%BA%8F%E5%91%98/">10X程序员</a><span class="widget-list-count">4</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/HTTP/">HTTP</a><span class="widget-list-count">2</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/">前端开发</a><span class="widget-list-count">35</span><ul class="widget-list-child"><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/CSS/">CSS</a><span class="widget-list-count">6</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/">JavaScript</a><span class="widget-list-count">9</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React/">React</a><span class="widget-list-count">12</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/umi/">umi</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91/">开发</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BE%AE%E4%BF%A1/">微信</a><span class="widget-list-count">3</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">移动端</a><span class="widget-list-count">2</span></li></ul></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E5%AE%9E%E6%88%98/">实战</a><span class="widget-list-count">5</span><ul class="widget-list-child"><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E5%AE%9E%E6%88%98/%E5%85%AC%E5%8F%B8%E9%A1%B9%E7%9B%AE/">公司项目</a><span class="widget-list-count">3</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E5%AE%9E%E6%88%98/%E7%8B%AC%E7%AB%8B%E9%A1%B9%E7%9B%AE/">独立项目</a><span class="widget-list-count">2</span></li></ul></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E5%BA%93/">库</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E5%BC%80%E5%8F%91%E4%BD%93%E9%AA%8C/">开发体验</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">开发环境</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E5%BE%AE%E4%BF%A1/">微信</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E6%9C%89%E7%9F%A5%E6%9C%89%E8%A1%8C/">有知有行</a><span class="widget-list-count">8</span><ul class="widget-list-child"><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E6%9C%89%E7%9F%A5%E6%9C%89%E8%A1%8C/%E5%86%99%E4%BD%9C/">写作</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E6%9C%89%E7%9F%A5%E6%9C%89%E8%A1%8C/%E5%88%86%E4%BA%AB/">分享</a><span class="widget-list-count">4</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E6%9C%89%E7%9F%A5%E6%9C%89%E8%A1%8C/%E5%AD%A6%E4%B9%A0/">学习</a><span class="widget-list-count">3</span></li></ul></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/">服务端开发</a><span class="widget-list-count">9</span><ul class="widget-list-child"><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/Koa2/">Koa2</a><span class="widget-list-count">3</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/Node/">Node</a><span class="widget-list-count">2</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%83%A8%E7%BD%B2/">部署</a><span class="widget-list-count">4</span></li></ul></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E7%90%86%E8%B4%A2/">理财</a><span class="widget-list-count">1</span><ul class="widget-list-child"><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E7%90%86%E8%B4%A2/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/">加密货币</a><span class="widget-list-count">1</span></li></ul></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/">疑难杂症</a><span class="widget-list-count">2</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E7%A2%8E%E7%9A%AE%E6%89%AF%E6%B7%A1/">碎皮扯淡</a><span class="widget-list-count">2</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><span class="widget-list-count">8</span><ul class="widget-list-child"><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Git/">Git</a><span class="widget-list-count">3</span></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/">JavaScript</a><span class="widget-list-count">5</span></li></ul></li><li class="widget-list-item"><a class="widget-list-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a><span class="widget-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><h3> 归档</h3></div><ul class="widget-list"><li class="widget-list-item"><a class="widget-list-link" href="/archives/2023/08/">2023年八月</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2023/07/">2023年七月</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2023/06/">2023年六月</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2023/05/">2023年五月</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2023/04/">2023年四月</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2023/03/">2023年三月</a><span class="widget-list-count">2</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2023/02/">2023年二月</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2023/01/">2023年一月</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2022/12/">2022年十二月</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2022/10/">2022年十月</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2022/09/">2022年九月</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2022/08/">2022年八月</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2022/07/">2022年七月</a><span class="widget-list-count">2</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2022/05/">2022年五月</a><span class="widget-list-count">2</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2022/04/">2022年四月</a><span class="widget-list-count">4</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2022/03/">2022年三月</a><span class="widget-list-count">7</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2022/02/">2022年二月</a><span class="widget-list-count">8</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2022/01/">2022年一月</a><span class="widget-list-count">5</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2021/12/">2021年十二月</a><span class="widget-list-count">8</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2021/11/">2021年十一月</a><span class="widget-list-count">8</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2021/10/">2021年十月</a><span class="widget-list-count">5</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2021/09/">2021年九月</a><span class="widget-list-count">5</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2021/08/">2021年八月</a><span class="widget-list-count">8</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2021/05/">2021年五月</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2021/04/">2021年四月</a><span class="widget-list-count">2</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2021/02/">2021年二月</a><span class="widget-list-count">1</span></li><li class="widget-list-item"><a class="widget-list-link" href="/archives/2020/11/">2020年十一月</a><span class="widget-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><h3>友情链接</h3></div><ul></ul><a href="https://azhubaby.com/" title="个人网站" target="_blank">个人网站</a><ul></ul><a href="https://fe.azhubaby.com/" title="五年前端三年面试" target="_blank">五年前端三年面试</a></div></div></div></div></div><footer id="footer"><div class="container"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>© 2024 <span>本站总访问量：<span id="busuanzi_value_site_pv"></span>&nbsp;次</span>
<span>总访客：<span id="busuanzi_value_site_uv"></span>人</span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo. &nbsp;</a>Theme by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></footer><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.2"><script type="text/javascript" src="/js/search.js?v=1.0.2"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'search-input', 'search-results');
</script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.2"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.2"></script><div class="search-page"><div class="search-icon-close-container"><span class="search-icon-close"><i class="fa fa-chevron-down"></i></span></div><div class="search-main container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><form></form><input type="text" id="search-input" placeholder="searching..."><div class="mini-post-list" id="search-results"></div></div></div></div></div></body></html>